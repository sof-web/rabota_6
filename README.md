Вариант 1. Жадный алгоритм для вершинного покрытия

    Инициализация: Создать пустое множество cover для хранения вершин покрытия. Создать копию remaining_edges множества всех ребер графа.
    Пока есть непокрытые ребра: Пока remaining_edges не пусто:
    a. Выбор ребра: Выбрать произвольное ребро (u, v) из remaining_edges.
    b. Добавление вершин: Добавить обе вершины u и v этого ребра в множество cover.
        Пример строки кода (Python): cover.add(u); cover.add(v)
        c. Удаление инцидентных ребер: Удалить из remaining_edges все ребра, которые инцидентны u или v. Это означает, что любое ребро (u, x) или (v, y) будет удалено.
        Пример строки кода (Python): remaining_edges = {(a, b) for a, b in remaining_edges if a != u and a != v and b != u and b != v} (это выражение создает новое множество, исключая инцидентные ребра).
         
    Возврат результата: Вернуть множество cover.
     

Анализ: Алгоритм выбирает ребра, которые точно не покрыты. Для каждого выбранного ребра он добавляет две вершины. В оптимальном решении для этого же ребра нужно было бы выбрать хотя бы одну вершину. Поэтому, в худшем случае, наш алгоритм добавит в 2 раза больше вершин, чем оптимальное решение, обеспечивая 2-аппроксимацию. 


1. Определение приближенных алгоритмов
Что такое приближенный алгоритм и какова его основная цель в решении NP-сложных задач?

Приближенный алгоритм — это алгоритм, предназначенный для решения оптимизационных задач, в частности NP-сложных, для которых поиск точного оптимального решения требует чрезмерно большого (неполиномиального) времени вычислений. 

Его основная цель — найти решение, близкое к оптимальному, но при этом за полиномиальное время. Вместо того чтобы искать идеальный ответ (что часто невозможно на практике для NP-сложных задач), приближенный алгоритм гарантирует, что найденное решение будет не хуже оптимального более чем в определенное количество раз, выраженное коэффициентом аппроксимации (α). Это позволяет получать практически полезные и вычислительно достижимые решения для задач, где точные алгоритмы неприменимы из-за их высокой сложности. 
