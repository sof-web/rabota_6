Вариант 1. Жадный алгоритм для вершинного покрытия

Инициализация:
Создать пустое множество cover для хранения вершин покрытия.
Создать копию remaining_edges множества всех ребер графа.
Пример из кода (Python):
     cover = set() # Создание пустого множества для покрытия
     remaining_edges = set(edges) # Создание копии множества ребер
Основной цикл:
Пока remaining_edges не пусто:

    a. Выбор ребра: Выбрать произвольное ребро (u, v) из remaining_edges. В реализации на Python set.pop() удаляет и возвращает произвольный элемент, что подходит под "произвольное ребро".
        Пример из кода (Python):
        u, v = remaining_edges.pop() # Выбор и удаление произвольного ребра
    b. Добавление вершин: Добавить обе вершины u и v этого ребра в множество cover.
        Пример из кода (Python):
        cover.add(u) # Добавление вершины u в покрытие
        cover.add(v) # Добавление вершины v в покрытие
    c. Удаление инцидентных ребер: Удалить из remaining_edges все ребра, которые инцидентны u или v. Это означает, что любое ребро (u, x) или (v, y) будет удалено. В реализации на Python это делается с помощью генератора множества, создавая новое множество, исключая ребра, инцидентные u или v.
        Пример из кода (Python):
        remaining_edges = {(a, b) for a, b in remaining_edges if a != u and a != v and b != u and b != v}
# Это выражение создает новое множество, исключая ребра, инцидентные u или v

Возврат результата: 

    После завершения цикла, когда все ребра покрыты, вернуть множество cover.
    Пример из кода (Python):
    return cover # Возврат найденного покрытия

Анализ: Алгоритм выбирает ребра, которые точно не покрыты. Для каждого выбранного ребра он добавляет две вершины. В оптимальном решении для этого же ребра нужно было бы выбрать хотя бы одну вершину. Поэтому, в худшем случае, наш алгоритм добавит в 2 раза больше вершин, чем оптимальное решение, обеспечивая 2-аппроксимацию. 


1. Определение приближенных алгоритмов
Что такое приближенный алгоритм и какова его основная цель в решении NP-сложных задач?

Приближенный алгоритм — это алгоритм, предназначенный для решения оптимизационных задач, в частности NP-сложных, для которых поиск точного оптимального решения требует чрезмерно большого (неполиномиального) времени вычислений. 

Его основная цель — найти решение, близкое к оптимальному, но при этом за полиномиальное время. Вместо того чтобы искать идеальный ответ (что часто невозможно на практике для NP-сложных задач), приближенный алгоритм гарантирует, что найденное решение будет не хуже оптимального более чем в определенное количество раз, выраженное коэффициентом аппроксимации (α). Это позволяет получать практически полезные и вычислительно достижимые решения для задач, где точные алгоритмы неприменимы из-за их высокой сложности. 
