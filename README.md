Вариант 1. Жадный алгоритм для вершинного покрытия

    Инициализация: Создать пустое множество cover для хранения вершин покрытия. Создать копию remaining_edges множества всех ребер графа.
    Пока есть непокрытые ребра: Пока remaining_edges не пусто:
    a. Выбор ребра: Выбрать произвольное ребро (u, v) из remaining_edges.
    b. Добавление вершин: Добавить обе вершины u и v этого ребра в множество cover.
        Пример строки кода (Python): cover.add(u); cover.add(v)
        c. Удаление инцидентных ребер: Удалить из remaining_edges все ребра, которые инцидентны u или v. Это означает, что любое ребро (u, x) или (v, y) будет удалено.
        Пример строки кода (Python): remaining_edges = {(a, b) for a, b in remaining_edges if a != u and a != v and b != u and b != v} (это выражение создает новое множество, исключая инцидентные ребра).
         
    Возврат результата: Вернуть множество cover.
     

Анализ: Алгоритм выбирает ребра, которые точно не покрыты. Для каждого выбранного ребра он добавляет две вершины. В оптимальном решении для этого же ребра нужно было бы выбрать хотя бы одну вершину. Поэтому, в худшем случае, наш алгоритм добавит в 2 раза больше вершин, чем оптимальное решение, обеспечивая 2-аппроксимацию. 
